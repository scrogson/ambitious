//! # starlang-macros
//!
//! Ergonomic macros for Starlang.
//!
//! This crate provides procedural macros that make working with Starlang
//! more convenient and Elixir-like.
//!
//! # Available Macros
//!
//! ## `#[main]`
//!
//! Entry point macro that sets up both tokio and the Starlang runtime:
//!
//! ```ignore
//! #[starlang::main]
//! async fn main(handle: RuntimeHandle) -> Result<(), Box<dyn std::error::Error>> {
//!     // Start your processes here
//!     let pid = handle.spawn(|ctx| async move {
//!         // Process logic
//!     });
//!     Ok(())
//! }
//! ```
//!
//! ## `receive!`
//!
//! Pattern matching on received messages with optional timeout:
//!
//! ```ignore
//! receive! { ctx,
//!     MyMessage::Ping => {
//!         println!("Got ping!");
//!     },
//!     MyMessage::Data(x) => {
//!         println!("Got data: {}", x);
//!     },
//!     after Duration::from_secs(5) => {
//!         println!("Timeout!");
//!     }
//! }
//! ```
//!
//! ## `#[derive(GenServerImpl)]`
//!
//! Derive macro for implementing GenServer boilerplate (future feature).

extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn::{DeriveInput, ItemFn, parse_macro_input};

/// Derive macro for GenServer implementation helpers.
///
/// This is a placeholder for future functionality. Currently it just
/// generates an empty impl block.
///
/// # Example
///
/// ```ignore
/// use starlang_macros::GenServerImpl;
///
/// #[derive(GenServerImpl)]
/// struct MyServer {
///     counter: i64,
/// }
/// ```
#[proc_macro_derive(GenServerImpl, attributes(gen_server))]
pub fn derive_gen_server_impl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;

    // For now, just generate an empty marker trait impl
    let expanded = quote! {
        impl #name {
            /// Returns the type name (generated by GenServerImpl derive).
            pub fn type_name() -> &'static str {
                stringify!(#name)
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for marking async functions as Starlang processes.
///
/// This is a placeholder for future functionality.
///
/// # Example
///
/// ```ignore
/// #[starlang_process]
/// async fn my_worker(ctx: Context) {
///     // Process logic
/// }
/// ```
#[proc_macro_attribute]
pub fn starlang_process(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // For now, just pass through the item unchanged
    item
}

/// Returns the current process's PID from task-local storage.
///
/// This macro is a convenient shorthand for `starlang::current_pid()`.
/// It can be called from within any Starlang process without needing
/// access to the Context.
///
/// # Panics
///
/// Panics if called outside of a Starlang process context.
///
/// # Example
///
/// ```ignore
/// use starlang::prelude::*;
///
/// starlang::spawn(|_ctx| async move {
///     let my_pid = starlang::self_pid!();
///     println!("My PID is {:?}", my_pid);
/// });
/// ```
#[proc_macro]
pub fn self_pid(_input: TokenStream) -> TokenStream {
    quote! {
        ::starlang::current_pid()
    }
    .into()
}

/// Entry point macro that sets up both tokio and the Starlang runtime.
///
/// This macro transforms an async main function into a synchronous main that:
/// 1. Starts the tokio runtime
/// 2. Initializes the global Starlang runtime
/// 3. Runs your async function
///
/// After initialization, you can use `starlang::spawn`, `starlang::handle()`, etc.
/// from anywhere in your code.
///
/// # Example
///
/// ```ignore
/// use starlang::prelude::*;
///
/// #[starlang::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // Spawn using the global runtime
///     let pid = starlang::spawn(|ctx| async move {
///         println!("Hello from Starlang!");
///     });
///
///     // Or get the handle explicitly
///     let handle = starlang::handle();
///
///     // Keep the runtime alive
///     tokio::signal::ctrl_c().await?;
///     Ok(())
/// }
/// ```
#[proc_macro_attribute]
pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);

    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_return = &input.sig.output;
    let fn_vis = &input.vis;
    let fn_attrs = &input.attrs;

    let expanded = quote! {
        #(#fn_attrs)*
        #fn_vis fn #fn_name() #fn_return {
            let rt = ::tokio::runtime::Runtime::new().expect("Failed to create tokio runtime");
            rt.block_on(async {
                // Initialize the global Starlang runtime
                ::starlang::init();
                #fn_block
            })
        }
    };

    TokenStream::from(expanded)
}

/// Test attribute macro that sets up the Starlang runtime for tests.
///
/// This macro wraps a test function with tokio's async runtime and
/// initializes the global Starlang runtime before running the test body.
///
/// # Example
///
/// ```ignore
/// use std::sync::Arc;
/// use std::sync::atomic::{AtomicBool, Ordering};
///
/// #[starlang::test]
/// async fn test_spawn_runs() {
///     let executed = Arc::new(AtomicBool::new(false));
///     let flag = executed.clone();
///
///     starlang::spawn(move || async move {
///         flag.store(true, Ordering::SeqCst);
///     });
///
///     // Give the process time to run
///     tokio::time::sleep(std::time::Duration::from_millis(10)).await;
///     assert!(executed.load(Ordering::SeqCst));
/// }
/// ```
#[proc_macro_attribute]
pub fn test(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);

    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_vis = &input.vis;
    let fn_attrs = &input.attrs;

    let expanded = quote! {
        #[::tokio::test]
        #(#fn_attrs)*
        #fn_vis async fn #fn_name() {
            ::starlang::init();
            #fn_block
        }
    };

    TokenStream::from(expanded)
}
