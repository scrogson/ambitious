//! # ambitious-macros
//!
//! Ergonomic macros for Ambitious.
//!
//! This crate provides procedural macros that make working with Ambitious
//! more convenient and Elixir-like.
//!
//! # Available Macros
//!
//! ## `#[main]`
//!
//! Entry point macro that sets up both tokio and the Ambitious runtime:
//!
//! ```ignore
//! #[ambitious::main]
//! async fn main(handle: RuntimeHandle) -> Result<(), Box<dyn std::error::Error>> {
//!     // Start your processes here
//!     let pid = handle.spawn(|ctx| async move {
//!         // Process logic
//!     });
//!     Ok(())
//! }
//! ```
//!
//! ## `receive!`
//!
//! Pattern matching on received messages with optional timeout:
//!
//! ```ignore
//! receive! { ctx,
//!     MyMessage::Ping => {
//!         println!("Got ping!");
//!     },
//!     MyMessage::Data(x) => {
//!         println!("Got data: {}", x);
//!     },
//!     after Duration::from_secs(5) => {
//!         println!("Timeout!");
//!     }
//! }
//! ```
//!
//! ## `#[derive(GenServerImpl)]`
//!
//! Derive macro for implementing GenServer boilerplate (future feature).

extern crate proc_macro;

use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::{Data, DeriveInput, Fields, ItemFn, ItemImpl, Type, parse_macro_input};

/// Derive macro for GenServer implementation helpers.
///
/// This is a placeholder for future functionality. Currently it just
/// generates an empty impl block.
///
/// # Example
///
/// ```ignore
/// use ambitious_macros::GenServerImpl;
///
/// #[derive(GenServerImpl)]
/// struct MyServer {
///     counter: i64,
/// }
/// ```
#[proc_macro_derive(GenServerImpl, attributes(gen_server))]
pub fn derive_gen_server_impl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;

    // For now, just generate an empty marker trait impl
    let expanded = quote! {
        impl #name {
            /// Returns the type name (generated by GenServerImpl derive).
            pub fn type_name() -> &'static str {
                stringify!(#name)
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for marking async functions as Ambitious processes.
///
/// This is a placeholder for future functionality.
///
/// # Example
///
/// ```ignore
/// #[ambitious_process]
/// async fn my_worker(ctx: Context) {
///     // Process logic
/// }
/// ```
#[proc_macro_attribute]
pub fn ambitious_process(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // For now, just pass through the item unchanged
    item
}

/// Returns the current process's PID from task-local storage.
///
/// This macro is a convenient shorthand for `ambitious::current_pid()`.
/// It can be called from within any Ambitious process without needing
/// access to the Context.
///
/// # Panics
///
/// Panics if called outside of a Ambitious process context.
///
/// # Example
///
/// ```ignore
/// use ambitious::prelude::*;
///
/// ambitious::spawn(|_ctx| async move {
///     let my_pid = ambitious::self_pid!();
///     println!("My PID is {:?}", my_pid);
/// });
/// ```
#[proc_macro]
pub fn self_pid(_input: TokenStream) -> TokenStream {
    quote! {
        ::ambitious::current_pid()
    }
    .into()
}

/// Entry point macro that sets up both tokio and the Ambitious runtime.
///
/// This macro transforms an async main function into a synchronous main that:
/// 1. Starts the tokio runtime
/// 2. Initializes the global Ambitious runtime
/// 3. Runs your async function
///
/// After initialization, you can use `ambitious::spawn`, `ambitious::handle()`, etc.
/// from anywhere in your code.
///
/// # Example
///
/// ```ignore
/// use ambitious::prelude::*;
///
/// #[ambitious::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // Spawn using the global runtime
///     let pid = ambitious::spawn(|ctx| async move {
///         println!("Hello from Ambitious!");
///     });
///
///     // Or get the handle explicitly
///     let handle = ambitious::handle();
///
///     // Keep the runtime alive
///     tokio::signal::ctrl_c().await?;
///     Ok(())
/// }
/// ```
#[proc_macro_attribute]
pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);

    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_return = &input.sig.output;
    let fn_vis = &input.vis;
    let fn_attrs = &input.attrs;

    let expanded = quote! {
        #(#fn_attrs)*
        #fn_vis fn #fn_name() #fn_return {
            let rt = ::tokio::runtime::Runtime::new().expect("Failed to create tokio runtime");
            rt.block_on(async {
                // Initialize the global Ambitious runtime
                ::ambitious::init();
                #fn_block
            })
        }
    };

    TokenStream::from(expanded)
}

/// Test attribute macro that sets up the Ambitious runtime for tests.
///
/// This macro wraps a test function with tokio's async runtime and
/// initializes the global Ambitious runtime before running the test body.
///
/// # Example
///
/// ```ignore
/// use std::sync::Arc;
/// use std::sync::atomic::{AtomicBool, Ordering};
///
/// #[ambitious::test]
/// async fn test_spawn_runs() {
///     let executed = Arc::new(AtomicBool::new(false));
///     let flag = executed.clone();
///
///     ambitious::spawn(move || async move {
///         flag.store(true, Ordering::SeqCst);
///     });
///
///     // Give the process time to run
///     tokio::time::sleep(std::time::Duration::from_millis(10)).await;
///     assert!(executed.load(Ordering::SeqCst));
/// }
/// ```
#[proc_macro_attribute]
pub fn test(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);

    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_vis = &input.vis;
    let fn_attrs = &input.attrs;

    let expanded = quote! {
        #[::tokio::test]
        #(#fn_attrs)*
        #fn_vis async fn #fn_name() {
            ::ambitious::init();
            #fn_block
        }
    };

    TokenStream::from(expanded)
}

/// Derive macro for implementing the Message trait.
///
/// This generates implementations for `encode_local`, `decode_local`,
/// `encode_remote`, and `decode_remote` with automatic type tagging.
///
/// # Supported Types
///
/// - Unit structs: `struct Ping;`
/// - Newtype structs: `struct Add(i64);`
/// - Structs with named fields: `struct Login { user: String, pass: String }`
///
/// # Attributes
///
/// - `#[message(tag = "custom")]` - Override the default tag (type name)
///
/// # Example
///
/// ```ignore
/// use ambitious::Message;
///
/// #[derive(Message)]
/// struct Get;
///
/// #[derive(Message)]
/// #[message(tag = "increment")]
/// struct Inc;
///
/// #[derive(Message)]
/// struct Add(i64);
///
/// #[derive(Message)]
/// struct SetUser {
///     name: String,
///     age: u32,
/// }
/// ```
/// Derive macro for the Message trait.
///
/// This macro automatically implements `Serialize` and `Deserialize` from serde,
/// so you don't need to derive them manually.
///
/// # Examples
///
/// ```ignore
/// use ambitious::Message;
///
/// // Unit struct - no payload
/// #[derive(Debug, Clone, Message)]
/// struct Ping;
///
/// // Newtype struct - wraps a single value
/// #[derive(Debug, Clone, Message)]
/// struct Add(i64);
///
/// // Named struct - multiple fields
/// #[derive(Debug, Clone, Message)]
/// struct SetUser {
///     name: String,
///     age: u32,
/// }
///
/// // Custom tag (defaults to struct name)
/// #[derive(Debug, Clone, Message)]
/// #[message(tag = "increment")]
/// struct Inc;
/// ```
#[proc_macro_derive(Message, attributes(message))]
pub fn derive_message(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let generics = &input.generics;
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // Check for custom tag attribute
    let tag = get_message_tag(&input).unwrap_or_else(|| name.to_string());

    // Generate different code based on struct variant
    let (encode_body, decode_body, serde_impl) = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Unit => {
                // Unit struct: struct Ping;
                // No serde needed - nothing to serialize
                (
                    quote! {
                        ::ambitious::message::encode_with_tag(Self::TAG, &[])
                    },
                    quote! {
                        let _ = bytes;
                        Ok(Self)
                    },
                    quote! {},
                )
            }
            Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {
                // Newtype struct: struct Add(i64);
                let field_ty = &fields.unnamed.first().unwrap().ty;
                (
                    quote! {
                        let payload = ::ambitious::message::encode_payload(&self.0);
                        ::ambitious::message::encode_with_tag(Self::TAG, &payload)
                    },
                    quote! {
                        let inner: #field_ty = ::ambitious::message::decode_payload(bytes)?;
                        Ok(Self(inner))
                    },
                    // Generate Serialize/Deserialize for newtype
                    quote! {
                        impl #impl_generics ::serde::Serialize for #name #ty_generics #where_clause {
                            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                            where
                                S: ::serde::Serializer,
                            {
                                self.0.serialize(serializer)
                            }
                        }

                        impl<'de> #impl_generics ::serde::Deserialize<'de> for #name #ty_generics #where_clause {
                            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                            where
                                D: ::serde::Deserializer<'de>,
                            {
                                let inner = <#field_ty as ::serde::Deserialize>::deserialize(deserializer)?;
                                Ok(Self(inner))
                            }
                        }
                    },
                )
            }
            Fields::Unnamed(_) => {
                // Multi-field tuple struct not supported yet
                return syn::Error::new_spanned(
                    input,
                    "Message derive only supports unit structs, newtype structs (single field), and named structs",
                )
                .to_compile_error()
                .into();
            }
            Fields::Named(fields) => {
                // Named struct: struct Login { user: String }
                let field_names: Vec<_> = fields.named.iter().map(|f| &f.ident).collect();
                let field_types: Vec<_> = fields.named.iter().map(|f| &f.ty).collect();
                let field_count = field_names.len();
                let field_strs: Vec<_> = field_names
                    .iter()
                    .map(|n| n.as_ref().map(|i| i.to_string()).unwrap_or_default())
                    .collect();

                (
                    quote! {
                        let payload = ::ambitious::message::encode_payload(&(#(&self.#field_names),*));
                        ::ambitious::message::encode_with_tag(Self::TAG, &payload)
                    },
                    quote! {
                        let (#(#field_names),*): (#(#field_types),*) = ::ambitious::message::decode_payload(bytes)?;
                        Ok(Self { #(#field_names),* })
                    },
                    // Generate Serialize/Deserialize for named struct
                    quote! {
                        impl #impl_generics ::serde::Serialize for #name #ty_generics #where_clause {
                            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                            where
                                S: ::serde::Serializer,
                            {
                                use ::serde::ser::SerializeStruct;
                                let mut state = serializer.serialize_struct(stringify!(#name), #field_count)?;
                                #(
                                    state.serialize_field(#field_strs, &self.#field_names)?;
                                )*
                                state.end()
                            }
                        }

                        impl<'de> #impl_generics ::serde::Deserialize<'de> for #name #ty_generics #where_clause {
                            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                            where
                                D: ::serde::Deserializer<'de>,
                            {
                                // Deserialize as tuple for simplicity (matches encode_payload)
                                let (#(#field_names),*): (#(#field_types),*) =
                                    ::serde::Deserialize::deserialize(deserializer)?;
                                Ok(Self { #(#field_names),* })
                            }
                        }
                    },
                )
            }
        },
        Data::Enum(_) => {
            // Enum: requires Serialize + Deserialize to already be derived
            // Uses encode_payload/decode_payload for the entire enum
            (
                quote! {
                    let payload = ::ambitious::message::encode_payload(self);
                    ::ambitious::message::encode_with_tag(Self::TAG, &payload)
                },
                quote! {
                    ::ambitious::message::decode_payload(bytes)
                },
                // No serde impl needed - user must derive Serialize/Deserialize
                quote! {},
            )
        }
        Data::Union(_) => {
            return syn::Error::new_spanned(input, "Message derive does not support unions")
                .to_compile_error()
                .into();
        }
    };

    let expanded = quote! {
        #serde_impl

        impl #impl_generics ::ambitious::message::Message for #name #ty_generics #where_clause {
            const TAG: &'static str = #tag;

            fn encode_local(&self) -> Vec<u8> {
                #encode_body
            }

            fn decode_local(bytes: &[u8]) -> Result<Self, ::ambitious::core::DecodeError> {
                #decode_body
            }

            fn encode_remote(&self) -> Vec<u8> {
                // For now, use same encoding as local
                // TODO: Implement ETF encoding
                self.encode_local()
            }

            fn decode_remote(bytes: &[u8]) -> Result<Self, ::ambitious::core::DecodeError> {
                // For now, use same decoding as local
                // TODO: Implement ETF decoding
                Self::decode_local(bytes)
            }
        }
    };

    TokenStream::from(expanded)
}

/// Extract custom tag from #[message(tag = "...")] attribute
fn get_message_tag(input: &DeriveInput) -> Option<String> {
    for attr in &input.attrs {
        if attr.path().is_ident("message")
            && let Ok(meta) = attr.meta.require_list()
        {
            let tokens = meta.tokens.to_string();
            // Simple parsing: look for tag = "value"
            if let Some(start) = tokens.find("tag") {
                let rest = &tokens[start..];
                if let Some(eq_pos) = rest.find('=') {
                    let after_eq = &rest[eq_pos + 1..].trim();
                    // Extract string value between quotes
                    if let Some(quote_start) = after_eq.find('"') {
                        let after_quote = &after_eq[quote_start + 1..];
                        if let Some(quote_end) = after_quote.find('"') {
                            return Some(after_quote[..quote_end].to_string());
                        }
                    }
                }
            }
        }
    }
    None
}

// Note: GenServer now uses the enum-based pattern which doesn't require
// attribute macros. See `ambitious::gen_server` for the new API.

/// Generate a unique static name from server and message types.
fn handler_static_name(prefix: &str, server: &Type, msg: &Type) -> syn::Ident {
    // Convert types to strings and sanitize for use as identifier
    let server_str = quote!(#server)
        .to_string()
        .replace([' ', ':', '<', '>', ','], "_");
    let msg_str = quote!(#msg)
        .to_string()
        .replace([' ', ':', '<', '>', ','], "_");
    format_ident!("__{}_{}_{}", prefix, server_str, msg_str)
}

// =============================================================================
// Channel v2 Handler Registration Macros
// =============================================================================

/// Extract the Channel type and Message type from `impl HandleIn<M> for C`.
fn extract_handle_in_types(impl_block: &ItemImpl) -> Option<(Type, Type)> {
    let channel_type = (*impl_block.self_ty).clone();
    let trait_path = impl_block.trait_.as_ref()?.1.clone();
    let last_segment = trait_path.segments.last()?;
    if last_segment.ident != "HandleIn" {
        return None;
    }

    if let syn::PathArguments::AngleBracketed(args) = &last_segment.arguments
        && let Some(syn::GenericArgument::Type(msg_type)) = args.args.first()
    {
        return Some((channel_type, msg_type.clone()));
    }

    None
}

/// Attribute macro for Channel HandleIn handler registration.
///
/// Apply this to an `impl HandleIn<M> for C` block to automatically register
/// the handler for dispatch. This macro also applies `#[async_trait]` automatically.
///
/// The attribute takes an event name as argument that maps to the incoming event string.
///
/// # Example
///
/// ```ignore
/// use ambitious::channel::v2::*;
/// use ambitious::Message;
///
/// #[derive(Message)]
/// struct NewMsg { text: String }
///
/// #[handle_in("new_msg")]
/// impl HandleIn<NewMsg> for RoomChannel {
///     type Reply = MessageBroadcast;
///
///     async fn handle_in(&mut self, msg: NewMsg, socket: &Socket) -> HandleResult<MessageBroadcast> {
///         HandleResult::Broadcast {
///             event: "new_msg".to_string(),
///             payload: MessageBroadcast { from: self.nick.clone(), text: msg.text },
///         }
///     }
/// }
/// ```
#[proc_macro_attribute]
pub fn handle_in(attr: TokenStream, item: TokenStream) -> TokenStream {
    let impl_block = parse_macro_input!(item as ItemImpl);

    // Parse the event name from the attribute (e.g., "new_msg")
    let event_name: syn::LitStr = match syn::parse(attr) {
        Ok(lit) => lit,
        Err(_) => {
            return syn::Error::new_spanned(
                &impl_block,
                "#[handle_in] requires an event name, e.g., #[handle_in(\"new_msg\")]",
            )
            .to_compile_error()
            .into();
        }
    };

    let Some((channel_type, msg_type)) = extract_handle_in_types(&impl_block) else {
        return syn::Error::new_spanned(
            &impl_block,
            "#[handle_in] can only be applied to `impl HandleIn<M> for C` blocks",
        )
        .to_compile_error()
        .into();
    };

    let static_name = handler_static_name("CHANNEL_IN", &channel_type, &msg_type);

    let expanded = quote! {
        #[::ambitious::channel::async_trait]
        #impl_block

        #[::ambitious::linkme::distributed_slice(::ambitious::channel::dispatch::HANDLE_IN_HANDLERS)]
        #[linkme(crate = ::ambitious::linkme)]
        static #static_name: ::ambitious::channel::dispatch::HandleInEntry = ::ambitious::channel::dispatch::HandleInEntry {
            channel_type_id: || ::std::any::TypeId::of::<#channel_type>(),
            event_name: || #event_name,
            dispatch: |channel_any, payload, socket| {
                Box::pin(async move {
                    use ::ambitious::channel::HandleIn;
                    use ::ambitious::message::Message;

                    let channel = channel_any.downcast_mut::<#channel_type>()
                        .expect("channel type mismatch in handle_in dispatch");

                    let msg = match <#msg_type>::decode_local(payload) {
                        Ok(m) => m,
                        Err(e) => {
                            return ::ambitious::channel::RawHandleResult::Stop {
                                reason: format!("decode error: {}", e),
                            };
                        }
                    };

                    let result = <#channel_type as HandleIn<#msg_type>>::handle_in(channel, msg, socket).await;
                    ::ambitious::channel::handle_result_to_raw(result)
                })
            },
        };
    };

    TokenStream::from(expanded)
}
